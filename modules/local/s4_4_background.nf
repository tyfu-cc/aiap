#!/usr/bin/env nextflow

process S4_4_BACKGROUND {
  publishDir "${params.outdir}-${meta.id}/4_4_background", mode: "copy"
  
  input:
  tuple(
    val(meta),
    path(input_bed),
    path(input_peak)
  )
  path(promoter_file)
  path(nochrM_chrom_size)

  output:
  tuple(
    val(meta),
    path("step4_4_promoter_percentage.result"),
    path("step4_4_background.result"),
    path("step4_4_dichoto_bg.result")
  )
  path("bin_${meta.id}.txt"), optional: true
  path("data_collection_s4_4.json"), emit: json

  script:
  """
  # signal part
  bedtools intersect -iobuf 200M -a ${input_peak} -b ${promoter_file} -u \
    | awk '{print \$1"\\t"\$2"\\t"\$3"\\t""1""\\t"\$9}' > promoter.narrowPeak
  bedtools intersect -iobuf 200M -a ${input_peak} -b ${promoter_file} -v \
    | awk '{print \$1"\\t"\$2"\\t"\$3"\\t""0""\\t"\$9}' > non-promoter.narrowPeak


  # Count peaks and reads in promoter and non-promoter regions
  peak1=\$(wc -l < promoter.narrowPeak)
  read1=\$(bedtools intersect -iobuf 200M -a ${input_bed} -b promoter.narrowPeak -u -f 0.50 | wc -l)
  peak2=\$(wc -l < non-promoter.narrowPeak)
  read2=\$(bedtools intersect -iobuf 200M -a ${input_bed} -b non-promoter.narrowPeak -u -f 0.50 | wc -l)

  {
    echo -e "num_peaks_in_promoter\\t\
      num_peaks_in_non-promoter\\t\
      num_reads_in_promoter_peaks\\t\
      num_reads_in_non-promoter_peaks"
    echo -e "\$peak1\\t\$peak2\\t\$read1\\t\$read2"
  } > step4_4_promoter_percentage.result
  sed -i 's/^-e //' step4_4_promoter_percentage.result

  cat promoter.narrowPeak non-promoter.narrowPeak \
    | sort -k5 -n -r > top10k.narrowPeak

  lines=\$(wc -l < top10k.narrowPeak)
  if (( \$lines > 100 )); then
    promoter_bin.py top10k.narrowPeak bin_${meta.id}.txt
  else
    echo "Warning: total peak is fewer than 100, promoter bin step would be skipped. At least 100 peaks are required."
  fi

  # Background noise estimation
  # chr.peak will be generated by random_chr.py
  awk 'length(\$1) > 1 && length(\$1) < 6' OFS="\\t" ${nochrM_chrom_size} > temp4_4.txt
  random_chr.py temp4_4.txt chr.peak

  size=\$(wc -l < ${input_bed})

  awk '{
    x = int((\$2 + \$3) / 2)
    if (x - 100000 < 0) x = 100000
    print \$1, x - 100000, x + 100000, \$4
  }' OFS="\\t" ${input_peak} > temp4_5.txt

  bedtools intersect -iobuf 200M -a chr.peak -b temp4_5.txt -v | shuf - | head -50000 | sort -k1,1V -k2,2n > background
  bedtools intersect -iobuf 200M -a ${input_bed} -b background -u -f 0.5 | sort -k1,1V -k2,2n > temp4_6.txt
  # read.txt will be generated by rpkm_bin
  rpkm_bin.py background temp4_6.txt \$size step4_4_background.result

  # Calculate background distribution
  bg_total=\$(wc -l < step4_4_background.result)
  bg_half_thres=\$(awk '\$6 <= 0.188 {print \$0}' step4_4_background.result | wc -l)
  bg_less=\$(awk '\$6 <= 0.377 {print \$0}' step4_4_background.result | wc -l)
  bg_more=\$(awk '\$6 > 0.377 {print \$0}' step4_4_background.result | wc -l)

  echo "bg total: \$bg_total"
  echo "3 bg: \$bg_half_thres, \$bg_less, \$bg_more"

  ra_half_thres=\$(echo "scale=2; \$bg_half_thres * 100 / \$bg_total" | bc -l)
  ra_less=\$(echo "scale=2; \$bg_less * 100 / \$bg_total" | bc -l)
  ra_more=\$(echo "scale=2; \$bg_more * 100 / \$bg_total" | bc -l)

  jq --argjson ra_more \$ra_more \
    '.bg_gt37_percentage = \$ra_more' -n > data_collection_s4_4.json 

  echo -e "\$ra_half_thres\\t\$ra_less\\t\$ra_more" > step4_4_dichoto_bg.result
  """
}
